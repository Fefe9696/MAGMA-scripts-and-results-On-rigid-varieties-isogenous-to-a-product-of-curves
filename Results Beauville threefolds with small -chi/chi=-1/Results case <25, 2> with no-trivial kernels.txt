
// We are going to find all possibile Beauville threefolds with group G=C5^2 with chi=-1 and no-trivial kernels. 

// Let us consider all the possibile no-trivial kernels of C5^2 satisfying Remark 3.8. We also apply the natural action of Aut(G)xS3 on the set of triples of kernels to avoid repetitions. 

SetSeq:=function(T);
Tnew:=[];
for v in T do 
Tnew:=Append(Tnew,v);
end for;
return Tnew;
end function;


// This function determines all possible triples of kernels
// modulo the action of Aut(G)xS3. We assume that at least one kernel is 
// not trivial. Moreover, we assume that all kernels are different from 
// the full group G. 

KernOrbit:=function(G)
Aut:=AutomorphismGroup(G); 
f,P:= PermutationRepresentation(Aut);
Set:={};
 NG0:=NormalSubgroups(G);
for i in [1..#NG0-1] do
for j in [1..#NG0-1] do
for k in [2..#NG0-1] do
	K1:=NG0[i]`subgroup; K2:=NG0[j]`subgroup; K3:=NG0[k]`subgroup;
if #(K1 meet K2) eq 1 and #(K2 meet K3) eq 1 and #(K1 meet K3) eq 1  then 
Set:=Include(Set,{*K1,K2,K3*});
end if;
end for;
end for;
end for;

Repres:={};
while not IsEmpty(Set) do 
T:=Rep(Set); Include(~Repres,SetSeq(T)); 
   for p in P do
	phi:=p @@ f; Tnew:={* *};
		for ke in T do 
			Tnew:=Include(Tnew,phi(ke));
		end for; 
		Exclude(~Set, Tnew);
    end for; 
end while; 
return Repres;
end function;

G:=SmallGroup(25,2);

SeqKerns:=SetToSequence(KernOrbit(G));
[
    [
        GrpPC of order 1
        PC-Relations:,

        GrpPC of order 5
        PC-Relations:
            $.1^5 = Id($),

        GrpPC of order 5
        PC-Relations:
            $.1^5 = Id($)
    ],
    [
        GrpPC of order 5
        PC-Relations:
            $.1^5 = Id($),

        GrpPC of order 5
        PC-Relations:
            $.1^5 = Id($),

        GrpPC of order 5
        PC-Relations:
            $.1^5 = Id($)
    ],
    [
        GrpPC of order 1
        PC-Relations:,

        GrpPC of order 1
        PC-Relations:,

        GrpPC of order 5
        PC-Relations:
            $.1^5 = Id($)
    ]
]

// Let us investigate which these subgroups are: 

seq1:=SeqKerns[1];
Sub:=seq1[1];
G!Sub.1;
Id(G)

Sub:=seq1[2]; 
G!Sub.1;     
G.1 * G.2

Sub:=seq1[3];
G!Sub.1;     
G.1

// Thus the first triple of kernels is <Id(G)>, <e1+e2>, <e1>. 

seq2:=SeqKerns[2];  

Sub:=seq2[1];     
G!Sub.1;          
G.1 * G.2

Sub:=seq2[2];
G!Sub.1;     
G.1

Sub:=seq2[3];
G!Sub.1;     
G.2

// Thus the second triple of kernels is <e1+e2>, <e1>, <e2>.

seq3:=SeqKerns[3];

Sub:=seq3[1];     
G!Sub.1;          
Id(G)

Sub:=seq3[2];     
G!Sub.1;     
Id(G)

Sub:=seq3[3];
G!Sub.1;     
G.1 * G.2

// Finally, the third triple of kernels is <Id(G)>, <Id(G)>, <e1+e2>.

// The quotient by one of these subgroups is either G (when the subgroup is trivial) or C5. Since we are looking for Beauville threefolds with chi=-1 and the genus of a covering of P1 by a group G is 6 and the genus of a covering of P^1 by a group C5 is 2, then we have to impose 

// chi=-1=1/25* 5^a*1^b  so that a=2 and b=1. 

// Thus the only possibile case to consider is the third triple of kernels 

// Let us find all spherical system of generators (up to equivalence) of signature [5,5,5] of G and C5: 

// We load gullinbursti database together with 

load"ExSphSyst.txt";

test, S:=generatorsFixedGroupFromDb(G,25,2,MultisetToSequence({*5, 5, 5*}));

S;
{
    [ G.1, G.2 , G.1^4 * G.2^4 ]
}

H:=SmallGroup(5,1);

S;
{
    [ H.1, H.1, H.1^3 ]
}

// Thus a sequence of elements of G whose quotient by <e1+e2> is a spherical system of generators of type [5,5,5] is [G.1, G.1, G.1^3]. 

S:=[[ G.1, G.2, G.1^4 * G.2^4 ],
    [ G.1, G.2, G.1^4 * G.2^4 ],
    [G.1, G.1, G.1^3]];

K:=[sub<G| Id(G)>, sub< G| Id(G)>, sub<G|G.1*G.2>];

load"Counting_PQ_varieties_from_SSGs_with_Kernels.txt";

time Final:=Counting_PQ_from_Classes_SSG_with_Kernels(G,K,S);
Time: 559.330

#Final;
182

// We have to select only those that are smooth:

load"Triple_of_Signatures_giving_Beauville_threefolds_with_fixed_chi.txt";

Final:=[[*G, x*]: x in Final];
FinalSmooth:=SmoothCondOfTheList_withKernels(Final, K[1],K[2],K[3]);
#FinalSmooth;
8

List:=[x[2]: x in FinalSmooth];

List;
[
    [
        [ G.1 * G.2, G.2, G.1^4 * G.2^3 ],
        [ G.1^3, G.1^4 * G.2, G.1^3 * G.2^4 ],
        [ G.2^4, G.2^4, G.2^2 ]
    ],
    [
        [ G.1^2 * G.2, G.1^3 * G.2, G.2^3 ],
        [ G.1^2 * G.2^2, G.1^2 * G.2^3, G.1 ],
        [ G.2^2, G.2^2, G.2 ]
    ],
    [
        [ G.1^3 * G.2^4, G.1^4 * G.2^3, G.1^3 * G.2^3 ],
        [ G.2^3, G.1^2, G.1^3 * G.2^2 ],
        [ G.2^3, G.2^3, G.2^4 ]
    ],
    [
        [ G.1^3 * G.2^4, G.2^4, G.1^2 * G.2^2 ],
        [ G.1^3 * G.2, G.1 * G.2^4, G.1 ],
        [ G.2^4, G.2^4, G.2^2 ]
    ],
    [
        [ G.1^4 * G.2, G.2^2, G.1 * G.2^2 ],
        [ G.1^2, G.1 * G.2^3, G.1^2 * G.2^2 ],
        [ G.2^2, G.2^2, G.2 ]
    ],
    [
        [ G.1 * G.2^3, G.1 * G.2, G.1^3 * G.2 ],
        [ G.1^2 * G.2^3, G.2^2, G.1^3 ],
        [ G.2^4, G.2^4, G.2^2 ]
    ],
    [
        [ G.1^4 * G.2, G.1, G.2^4 ],
        [ G.1^3 * G.2^3, G.1^3 * G.2^4, G.1^4 * G.2^3 ],
        [ G.2^2, G.2^2, G.2 ]
    ],
    [
        [ G.1^4 * G.2^2, G.1 * G.2^2, G.2 ],
        [ G.1^3 * G.2^3, G.1^4, G.1^3 * G.2^2 ],
        [ G.2^4, G.2^4, G.2^2 ]
    ]
]

// We determine the Hodge numbers of each of these threefolds. 

load"Hodge_Diamond.txt";

K:=sub<G|G.1*G.2>;
GQ, pi:=G/K;
T:=[0,5,5,5];
HodgeList:=[];

for X in List do 
  V1:=X[1]; V2:=X[2]; V3:=[pi(X[3][j]): j in [1..#X[3]] ];
  X1:=chi_phi(G,V1,T); X2:=chi_phi(G,V2,T); Y3:=chi_phi(GQ,V3,T); 
  X3:=LiftCharacter(Y3, pi, G); 
 Append(~HodgeList, HodgeDiamondInvarG0(G,X1,X2,X3));
end for;


HodgeList;
[
    [ 3, 1, 0, 5, 9 ],
    [ 4, 2, 0, 3, 8 ],
    [ 2, 0, 0, 7, 10 ],
    [ 3, 1, 0, 5, 9 ],
    [ 2, 0, 0, 7, 10 ],
    [ 3, 1, 0, 5, 9 ],
    [ 3, 1, 0, 5, 9 ],
    [ 4, 2, 0, 3, 8 ]
]


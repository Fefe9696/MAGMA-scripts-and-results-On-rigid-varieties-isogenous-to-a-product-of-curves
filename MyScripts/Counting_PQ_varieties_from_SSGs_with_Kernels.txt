//////////////////////////////////////////////////////////////////////////////////////////////////

// The first two scripts take in input a spherical system of generators V of G and an automorphism f 
// of G. It returns true if f is of braid type on V, and false otherwise. 
// The first script works for G abelian group, and the second for G not abelian (in which case we 
// need to give one input more, namely the orbit of V by the braid group (This is computable through
// a function written below). 


IsBraidType_Abelian:=function(V, f);
  IsBraidType:=false;
  if {*f(V[i ]) : i in [1..#V] *} eq {* V[i ] : i in [1..#V] *} then
     IsBraidType:=true;
  end if;
  return IsBraidType;
end function;


IsBraidType_NotAb:=function(V, BraidV, f)
    IsBraidType_NoAb:=false;
    if [f(V[i ]) : i in [1..#V]] in BraidV then 
      IsBraidType_NoAb:=true;
    end if;
    return IsBraidType_NoAb;
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////

// The function "BraidMove"  performs the i-th Hurwitz move 

BraidMove:=function(V,i)
   c:=V[i]*V[i+1]*V[i]^-1;
   return Insert(Remove(V,i+1),i,c); 
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////

// The function "BraidOrbit" determines the orbit of a given spherical system of generators V of 
// length r wrt the braid group B_r. Hence the output is the set {sigma* V: sigma in Br}.  


BAutGV:=function(V,G,r,P)
if IsAbelian(G) then 
    BAutG_V:={p : p in P | IsBraidType_Abelian(V, p @@ r ) eq true};
   return sub<P| BAutG_V>;
else 
orb:={ }; Trash:={V}; GENSBrGroupV:=[];
 repeat
    ExtractRep(~Trash,~gens); Include(~orb, gens);
		for i in [1..#V-1] do newgens:=BraidMove(gens,i);
			if newgens notin orb then 
				Include(~Trash, newgens);
                                  S:={p : p in P | [(p @@ r)(V[i]) : i in [1..#V]] eq newgens};
                                  if not IsEmpty(S) then 
                                     phi:=Random(S); Include(~GENSBrGroupV, phi);
                                  end if;
			end if; 
		end for;
                 H:=sub<P | GENSBrGroupV>; 
                 //subgroup:={(r^-1)(F): F in H};
                 //#subgroup;
                 //#orb;
until Order(H) eq Order(P) or IsEmpty(Trash);

if Order(H) eq Order(P) then 
   BrGroupV:=H;
else 
   BrGroupV:={p : p in P | IsBraidType_NotAb(V, orb, p @@ r) eq true };
   BrGroupV:=sub<P| BrGroupV>;
end if;
return BrGroupV;

end if;
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////

test_ordering:=function(V) 
     test:= true;
     for i in [1..#V-1] do 
       if Order(V[i ]) gt Order(V[i+1 ]) then 
            test:= false;
            break i;
       end if;
     end for;
     return test;
end function;

// This function returns a ordered spherical system of generators V' which belongs to the same braid 
// orbit of V

Ordering:=function(V)
    repeat 
       signature :=[Order(V[i ]) : i in [1..#V]];
       for i in [1..#V-1] do 
          if Order(V[i ]) ge Order(V[i +1]) then
             vi :=V[i];
             V[i]:=V[i]*V[i+1]*V[i]^-1;
             V[i+1]:=vi;
          end if;
       end for;
    until (signature eq Sort(signature)); 
    return V;
end function;


////////////////////////////////////////////////////////////////////////////////////////////////


// The next function takes in input a finite group G and a n-uple of pairwise distinct normal subgroups (N1,...,Nk) of G and returns the stabiliser AutG_K of K in AutG

Construction_AutGK:=function(G,K,AutG,r,P)
  AutG_KP:={};
  for phi in P do 
    for j in [1..#K] do 
     if {(phi @@ r)(g): g in K[j]} ne { g : g in K[j]} then 
        break j;
     elif j eq #K then
        Include(~AutG_KP, phi); 
     end if;
    end for;
  end for;
 return  sub<P| AutG_KP>;   // { p @@ r : p in AutG_KP};
end function;



////////////////////////////////////////////////////////////////////////////////////////////////


// We define the big group Prod_Aut(G/N_i)^n_i

Prod_Aut:=function(G,K)
   
   seqAut:=[**];
   for j in [1..#K] do 
       if exists(x){ t : t in [1..j-1] | K[t] eq K[j]} then 
           Append(~seqAut, seqAut[x]);
       else 
          Quot,pi:=quo<G| K[j]>;
          r,P:=PermutationRepresentation(AutomorphismGroup(Quot));
          Append(~seqAut,[*r,P, Quot, pi*]);
       end if;
   end for;

   return  CartesianProduct([seqAut[j][2]: j in [1..#seqAut]]), seqAut;
end function;


////////////////////////////////////////////////////////////////////////////////////////////////


// This function constructs the group Aut_K(G)xProd_BAut(G/Ki,Si). The S-input is a sequence of sequences of elements of G, such that the elements of S[i] viewed on G/Ki are spherical system of generators of G/Ki

Prod_BAutG_mod_Ki:=function(seqAut, G, K, S, r,P)
  seqBAut:=[**];


  for j in [1..#K] do 
   V:={ t : t in [1..j-1] | K[t] eq K[j]};
   if #V ne 0 then 
      if exists(y){ t : t in V | S[j] eq S[t]} then 
        Append(~seqBAut, seqBAut[y]);
      else 
        rj:=seqAut[j][1];
        Pj:=seqAut[j][2];
        GmodKj:=seqAut[j][3];
        pi:=seqAut[j][4];
        Append(~seqBAut, BAutGV([  pi(S[j][i]) : i in [1..#S[j]] ] , GmodKj,rj,Pj));
      end if;
   else 
        rj:=seqAut[j][1];
        Pj:=seqAut[j][2];
        GmodKj:=seqAut[j][3];
        pi:=seqAut[j][4];
        Append(~seqBAut, BAutGV([  pi(S[j][i]) : i in [1..#S[j]] ] , GmodKj,rj,Pj));
   end if;
   end for;
  // AutG:=AutomorphismGroup(G); r,P:=PermutationRepresentation(AutG);
  Aut_KG:=Construction_AutGK(G,K,Domain(r),r,P);

   return CartesianProduct( [Aut_KG] cat [seqBAut[j]: j in [1..#seqBAut]]), seqBAut;
end function;


////////////////////////////////////////////////////////////////////////////////////////////////

// We construct the action of a generic element phi belonging to Aut_K(G)xProd_BAut(G/Ki,Si) on an element y of ProdAut

Action:=function(phi, y, SeqProdAut, r);
   phi_y:=y;
   Phi:=phi[1] @@ r;
   for i in [1..#y] do 
      Quot:=SeqProdAut[i][3];
      pi:=SeqProdAut[i][4];
      Phi_mod_Ki:=hom< Quot -> Quot | [<x, pi(Phi(x @@ pi))>: x in Quot]>;
      r:=SeqProdAut[i][1]; // map from Aut(Quot) to PAut(Quot);
      Phi_mod_Ki_P:=r(Domain(r)!Phi_mod_Ki); // we see Phi as a permutation
      phi_y[i]:=(phi[i+1]*y[i])*Phi_mod_Ki_P;
   end for;
   return phi_y;
end function;

Reduced_Action:=function(phi, y);  
   phi_y:=y;
   for i in [1..#y] do
     phi_y[i]:=(phi[i+1]*y[i])*phi[1];
   end for;
   return phi_y;
end function;

////////////////////////////////////////////////////////////////////////////////////////////////

// Now we construct the quotient of ProdAut by the action of Aut_K(G)xProd_BAut(G/Ki,Si), shortly written as ProdBAut. 

Quot_ProdAut_mod_ProdBAut:=function(G, K, S, ProdAut, SeqProdAut)
  //  ProdAut,SeqProdAut:=Prod_Aut(G,K);
   AutG:=AutomorphismGroup(G); r,P:=PermutationRepresentation(AutG);
   ProdBAut:=Prod_BAutG_mod_Ki(SeqProdAut, G,K,S, r, P);
   if &*[#ProdBAut[j]: j in [2..#S+1]] eq #ProdAut then 
     Classes:=[{phi : phi in ProdAut}];
     return Classes, map< Classes -> ProdAut | C:->( <Id(ProdAut[j]): j in [1..#K]>  in C select <Id(ProdAut[j]): j in [1..#K]>  else Representative(C))>;
   end if;
   
   if &*[#ProdBAut[j]: j in [1..#S+1]]/&*[#ProdBAut[j]: j in [2..#S+1]] eq #AutG then // This means AutG_K=AutG, and we can then reduce the complexity of the computation
     if #{S[j]: j in [1..#S]} eq #S then 
      Classes:=[];
      Processed:={};
      for x in CartesianProduct([ProdAut[j] : j in [2..#S]]) do 
        if x notin Processed then 
        Class:={Reduced_Action(phi, x): phi in CartesianProduct([ProdBAut[j]: j in [2..#S+1]]) };
        Append(~Classes, Class);
        Processed join:=Class;
        end if;
      end for;
     
     f:=map< Classes -> ProdAut | C:->( <Id(ProdAut[1])> cat <Representative(C)[j] : j in [1..#S-1]>)>; 
     FinalClasses:=[{f(C)} : C in Classes];
     return FinalClasses, map< FinalClasses -> ProdAut | C:->( Representative(C))>;
     
     end if;
   end if;


  // seq_subgrs_eq_to_Kj:=[i : i in [1..#K] | K[i] eq Kj]; 
 //  mult_Sk_with_eq_Kj:=map< Integers() -> PowerSequence(Integers()) | x :-> [ y : y in seq_subgrs_eq_to_Kj | S[y] eq S[x]] >; 

   Classes:=[];
   Processed:={};
   for x in ProdAut do
     if x notin Processed then 
      // x; //DEBUG
       Class:={Action(phi, x,SeqProdAut, r): phi in ProdBAut};
       Append(~Classes, Class);
       Processed join:=Class;
      end if;
    end for;
  return Classes, map< Classes -> ProdAut | C:->( <Id(ProdAut[j]): j in [1..#K]>  in C select <Id(ProdAut[j]): j in [1..#K]>  else Representative(C))>;
end function;
 

////////////////////////////////////////////////////////////////////////////////////////////////

// This is the action of a product of permutations of ProdSigma_j belonging to ProdSym on an element elt of the quotient ProdAut mod ProdBAut

Action_ProdSym:=function(elt, seq, multMap, ProdSigma_j)
  new_elt:=elt;
  
  for j in seq do 
    test:=exists(i){v : v in [1..#seq] | seq[v] eq j};
    Sigma:=ProdSigma_j[i];
    for t in [1..#multMap(j)] do 
      new_elt[multMap(j)[t]]:=elt[multMap(j)[t^Sigma]];
    end for;
  end for;
  return new_elt;
end function;


////////////////////////////////////////////////////////////////////////////////////////////////

// This takes an element y in ProdAut and it returns a class x0 of elements in ProdAut mod ProdBAut such that the element y belongs to the class x0

PreImage:=function(Map, y)
 Test:=exists(x0){x : x in Domain(Map) | y in x};
 return x0;
end function;


////////////////////////////////////////////////////////////////////////////////////////////////

// This defines the quotient of ProdAut/ProdBAut by the action of the group ProdSym. The orbits of this action are in bijection with all PQ varieties arising from the classes of SSG given by S  

Mod_SymGroups:=function(G,K,S,Classes,Map)
  mult_Sk_with_eq_Kj:=map< Integers() -> PowerSequence(Integers()) | x :-> [ y : y in [1..#S] | K[y] eq K[x] and S[y] eq S[x]]>; 
 
 
  
  seq:=[];
  set:={};
  for i in [1..#S] do 
    if mult_Sk_with_eq_Kj(i) notin set then 
       Append(~seq, i);
    end if;
    Include(~set, mult_Sk_with_eq_Kj(i));
  end for;


  Prod_Sym:=CartesianProduct([SymmetricGroup(#mult_Sk_with_eq_Kj(i)): i in seq]);
  CLs:=[];
  Processed:={};
   for x in Classes do
     if x notin Processed then 
     //  x; //DEBUG
       CC:={PreImage(Map, Codomain(Map)!Action_ProdSym(Representative(x), seq ,mult_Sk_with_eq_Kj, ProdSigma_j)) : ProdSigma_j in Prod_Sym };
        Append(~CLs, CC);
        Processed join:=CC;      
      end if;
    end for;
  return CLs, map< CLs -> Classes | CC:-> (exists(l){C : C in CC | <Id(Codomain(Map)[j]): j in [1..#K]> in C} select l else Representative(CC) )>;
end function;


////////////////////////////////////////////////////////////////////////////////////////////////

// This is the action of an automorphism phi of Quot=G/Ki on an sequence ssg belonging to S. Precisely, the function sends ssg to ssg mod Ki, then it applies the automorphism phi, and finally it comes back to G by the quotient map pi: G->Quot. 


Action_on_a_ssg:=function(phi, ssg, r, P, Quot, pi)
   Phi:=phi @@ r;
   Phi_ssg:=[Phi(pi(x)) @@ pi : x in ssg];
   return Phi_ssg;
end function;



////////////////////////////////////////////////////////////////////////////////////////////////

// This is the final function of the algorithm. It takes in input a group G, a sequence of kernels K and a sequence S of sequences of elements of G, such that S[i] is a spherical system of generators of G/K[i]. 
// It returns all Product-Quotient varieties arising from the topological types of G/K[i]-coverings of P^1 given by S[i] mod K[i], up to isomorphism. 

Counting_PQ_from_Classes_SSG_with_Kernels:=function(G,K,S) 
   ProdAut,SeqProdAut:=Prod_Aut(G,K);
   Classes, Map:=Quot_ProdAut_mod_ProdBAut(G,K,S,ProdAut,SeqProdAut);
   Final, FinalMap:=Mod_SymGroups(G,K,S,Classes, Map);
   
   return [ [Action_on_a_ssg(phi[j], S[j], SeqProdAut[j][1], SeqProdAut[j][2], SeqProdAut[j][3], SeqProdAut[j][4]) : j in [1..#S]] : phi in [Map(FinalMap(Final[k])) : k in [1..#Final]] ]; 
end function;